{
  "version": 3,
  "sources": ["../../../../../../node_modules/@angular/core/fesm2022/rxjs-interop.mjs"],
  "sourcesContent": ["/**\r\n * @license Angular v20.3.10\r\n * (c) 2010-2025 Google LLC. https://angular.dev/\r\n * License: MIT\r\n */\r\n\r\nimport { Observable, ReplaySubject } from 'rxjs';\r\nimport { takeUntil } from 'rxjs/operators';\r\nimport { assertInInjectionContext, inject, DestroyRef, RuntimeError, Injector, assertNotInReactiveContext, signal, PendingTasks } from './root_effect_scheduler.mjs';\r\nimport { getOutputDestroyRef, effect, untracked, computed, resource, encapsulateResourceError } from './resource.mjs';\r\nimport './not_found.mjs';\r\nimport './signal.mjs';\r\nimport '@angular/core/primitives/signals';\r\nimport '@angular/core/primitives/di';\r\nimport './effect.mjs';\r\n\r\n/**\r\n * Operator which completes the Observable when the calling context (component, directive, service,\r\n * etc) is destroyed.\r\n *\r\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\r\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\r\n * context](guide/di/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\r\n *\r\n * @publicApi 19.0\r\n */\r\nfunction takeUntilDestroyed(destroyRef) {\r\n    if (!destroyRef) {\r\n        ngDevMode && assertInInjectionContext(takeUntilDestroyed);\r\n        destroyRef = inject(DestroyRef);\r\n    }\r\n    const destroyed$ = new Observable((subscriber) => {\r\n        if (destroyRef.destroyed) {\r\n            subscriber.next();\r\n            return;\r\n        }\r\n        const unregisterFn = destroyRef.onDestroy(subscriber.next.bind(subscriber));\r\n        return unregisterFn;\r\n    });\r\n    return (source) => {\r\n        return source.pipe(takeUntil(destroyed$));\r\n    };\r\n}\r\n\r\n/**\r\n * Implementation of `OutputRef` that emits values from\r\n * an RxJS observable source.\r\n *\r\n * @internal\r\n */\r\nclass OutputFromObservableRef {\r\n    source;\r\n    destroyed = false;\r\n    destroyRef = inject(DestroyRef);\r\n    constructor(source) {\r\n        this.source = source;\r\n        this.destroyRef.onDestroy(() => {\r\n            this.destroyed = true;\r\n        });\r\n    }\r\n    subscribe(callbackFn) {\r\n        if (this.destroyed) {\r\n            throw new RuntimeError(953 /* ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode &&\r\n                'Unexpected subscription to destroyed `OutputRef`. ' +\r\n                    'The owning directive/component is destroyed.');\r\n        }\r\n        // Stop yielding more values when the directive/component is already destroyed.\r\n        const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\r\n            next: (value) => callbackFn(value),\r\n        });\r\n        return {\r\n            unsubscribe: () => subscription.unsubscribe(),\r\n        };\r\n    }\r\n}\r\n/**\r\n * Declares an Angular output that is using an RxJS observable as a source\r\n * for events dispatched to parent subscribers.\r\n *\r\n * The behavior for an observable as source is defined as followed:\r\n *    1. New values are forwarded to the Angular output (next notifications).\r\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\r\n *       For example by using `catchError`.\r\n *    3. Completion notifications stop the output from emitting new values.\r\n *\r\n * @usageNotes\r\n * Initialize an output in your directive by declaring a\r\n * class field and initializing it with the `outputFromObservable()` function.\r\n *\r\n * ```ts\r\n * @Directive({..})\r\n * export class MyDir {\r\n *   nameChange$ = <some-observable>;\r\n *   nameChange = outputFromObservable(this.nameChange$);\r\n * }\r\n * ```\r\n *\r\n * @publicApi 19.0\r\n */\r\nfunction outputFromObservable(observable, opts) {\r\n    ngDevMode && assertInInjectionContext(outputFromObservable);\r\n    return new OutputFromObservableRef(observable);\r\n}\r\n\r\n/**\r\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\r\n * to an observable.\r\n * It creates an observable that represents the stream of \"events firing\" in an output.\r\n *\r\n * You can subscribe to the output via `Observable.subscribe` then.\r\n *\r\n * @publicApi 19.0\r\n */\r\nfunction outputToObservable(ref) {\r\n    const destroyRef = getOutputDestroyRef(ref);\r\n    return new Observable((observer) => {\r\n        // Complete the observable upon directive/component destroy.\r\n        // Note: May be `undefined` if an `EventEmitter` is declared outside\r\n        // of an injection context.\r\n        const unregisterOnDestroy = destroyRef?.onDestroy(() => observer.complete());\r\n        const subscription = ref.subscribe((v) => observer.next(v));\r\n        return () => {\r\n            subscription.unsubscribe();\r\n            unregisterOnDestroy?.();\r\n        };\r\n    });\r\n}\r\n\r\n/**\r\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\r\n * As it reflects a state, the observable will always emit the latest value upon subscription.\r\n *\r\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\r\n *\r\n * `toObservable` must be called in an injection context unless an injector is provided via options.\r\n *\r\n * @publicApi 20.0\r\n */\r\nfunction toObservable(source, options) {\r\n    if (ngDevMode && !options?.injector) {\r\n        assertInInjectionContext(toObservable);\r\n    }\r\n    const injector = options?.injector ?? inject(Injector);\r\n    const subject = new ReplaySubject(1);\r\n    const watcher = effect(() => {\r\n        let value;\r\n        try {\r\n            value = source();\r\n        }\r\n        catch (err) {\r\n            untracked(() => subject.error(err));\r\n            return;\r\n        }\r\n        untracked(() => subject.next(value));\r\n    }, { injector, manualCleanup: true });\r\n    injector.get(DestroyRef).onDestroy(() => {\r\n        watcher.destroy();\r\n        subject.complete();\r\n    });\r\n    return subject.asObservable();\r\n}\r\n\r\n/**\r\n * Get the current value of an `Observable` as a reactive `Signal`.\r\n *\r\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\r\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\r\n * have the most recent value emitted by the subscription, and will throw an error if the\r\n * `Observable` errors.\r\n *\r\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\r\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\r\n * does not include an `undefined` type.\r\n *\r\n * By default, the subscription will be automatically cleaned up when the current [injection\r\n * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is\r\n * called during the construction of a component, the subscription will be cleaned up when the\r\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\r\n * passed instead.\r\n *\r\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\r\n * option can be specified instead, which disables the automatic subscription teardown. No injection\r\n * context is needed in this configuration as well.\r\n */\r\nfunction toSignal(source, options) {\r\n    typeof ngDevMode !== 'undefined' &&\r\n        ngDevMode &&\r\n        assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' +\r\n            'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\r\n    const requiresCleanup = !options?.manualCleanup;\r\n    if (ngDevMode && requiresCleanup && !options?.injector) {\r\n        assertInInjectionContext(toSignal);\r\n    }\r\n    const cleanupRef = requiresCleanup\r\n        ? (options?.injector?.get(DestroyRef) ?? inject(DestroyRef))\r\n        : null;\r\n    const equal = makeToSignalEqual(options?.equal);\r\n    // Note: T is the Observable value type, and U is the initial value type. They don't have to be\r\n    // the same - the returned signal gives values of type `T`.\r\n    let state;\r\n    if (options?.requireSync) {\r\n        // Initially the signal is in a `NoValue` state.\r\n        state = signal({ kind: 0 /* StateKind.NoValue */ }, { equal });\r\n    }\r\n    else {\r\n        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\r\n        state = signal({ kind: 1 /* StateKind.Value */, value: options?.initialValue }, { equal });\r\n    }\r\n    let destroyUnregisterFn;\r\n    // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\r\n    // this, we would subscribe to the observable outside of the current reactive context, avoiding\r\n    // that side-effect signal reads/writes are attribute to the current consumer. The current\r\n    // consumer only needs to be notified when the `state` signal changes through the observable\r\n    // subscription. Additional context (related to async pipe):\r\n    // https://github.com/angular/angular/pull/50522.\r\n    const sub = source.subscribe({\r\n        next: (value) => state.set({ kind: 1 /* StateKind.Value */, value }),\r\n        error: (error) => {\r\n            state.set({ kind: 2 /* StateKind.Error */, error });\r\n            destroyUnregisterFn?.();\r\n        },\r\n        complete: () => {\r\n            destroyUnregisterFn?.();\r\n        },\r\n        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\r\n        // \"complete\".\r\n    });\r\n    if (options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\r\n        throw new RuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n            '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\r\n    }\r\n    // Unsubscribe when the current context is destroyed, if requested.\r\n    destroyUnregisterFn = cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\r\n    // The actual returned signal is a `computed` of the `State` signal, which maps the various states\r\n    // to either values or errors.\r\n    return computed(() => {\r\n        const current = state();\r\n        switch (current.kind) {\r\n            case 1 /* StateKind.Value */:\r\n                return current.value;\r\n            case 2 /* StateKind.Error */:\r\n                throw current.error;\r\n            case 0 /* StateKind.NoValue */:\r\n                // This shouldn't really happen because the error is thrown on creation.\r\n                throw new RuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n                    '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\r\n        }\r\n    }, { equal: options?.equal });\r\n}\r\nfunction makeToSignalEqual(userEquality = Object.is) {\r\n    return (a, b) => a.kind === 1 /* StateKind.Value */ && b.kind === 1 /* StateKind.Value */ && userEquality(a.value, b.value);\r\n}\r\n\r\n/**\r\n * Operator which makes the application unstable until the observable emits, completes, errors, or is unsubscribed.\r\n *\r\n * Use this operator in observables whose subscriptions are important for rendering and should be included in SSR serialization.\r\n *\r\n * @param injector The `Injector` to use during creation. If this is not provided, the current injection context will be used instead (via `inject`).\r\n *\r\n * @developerPreview 20.0\r\n */\r\nfunction pendingUntilEvent(injector) {\r\n    if (injector === undefined) {\r\n        ngDevMode && assertInInjectionContext(pendingUntilEvent);\r\n        injector = inject(Injector);\r\n    }\r\n    const taskService = injector.get(PendingTasks);\r\n    return (sourceObservable) => {\r\n        return new Observable((originalSubscriber) => {\r\n            // create a new task on subscription\r\n            const removeTask = taskService.add();\r\n            let cleanedUp = false;\r\n            function cleanupTask() {\r\n                if (cleanedUp) {\r\n                    return;\r\n                }\r\n                removeTask();\r\n                cleanedUp = true;\r\n            }\r\n            const innerSubscription = sourceObservable.subscribe({\r\n                next: (v) => {\r\n                    originalSubscriber.next(v);\r\n                    cleanupTask();\r\n                },\r\n                complete: () => {\r\n                    originalSubscriber.complete();\r\n                    cleanupTask();\r\n                },\r\n                error: (e) => {\r\n                    originalSubscriber.error(e);\r\n                    cleanupTask();\r\n                },\r\n            });\r\n            innerSubscription.add(() => {\r\n                originalSubscriber.unsubscribe();\r\n                cleanupTask();\r\n            });\r\n            return innerSubscription;\r\n        });\r\n    };\r\n}\r\n\r\nfunction rxResource(opts) {\r\n    if (ngDevMode && !opts?.injector) {\r\n        assertInInjectionContext(rxResource);\r\n    }\r\n    return resource({\r\n        ...opts,\r\n        loader: undefined,\r\n        stream: (params) => {\r\n            let sub;\r\n            // Track the abort listener so it can be removed if the Observable completes (as a memory\r\n            // optimization).\r\n            const onAbort = () => sub?.unsubscribe();\r\n            params.abortSignal.addEventListener('abort', onAbort);\r\n            // Start off stream as undefined.\r\n            const stream = signal({ value: undefined });\r\n            let resolve;\r\n            const promise = new Promise((r) => (resolve = r));\r\n            function send(value) {\r\n                stream.set(value);\r\n                resolve?.(stream);\r\n                resolve = undefined;\r\n            }\r\n            // TODO(alxhub): remove after g3 updated to rename loader -> stream\r\n            const streamFn = opts.stream ?? opts.loader;\r\n            if (streamFn === undefined) {\r\n                throw new RuntimeError(990 /* ɵRuntimeErrorCode.MUST_PROVIDE_STREAM_OPTION */, ngDevMode && `Must provide \\`stream\\` option.`);\r\n            }\r\n            sub = streamFn(params).subscribe({\r\n                next: (value) => send({ value }),\r\n                error: (error) => {\r\n                    send({ error: encapsulateResourceError(error) });\r\n                    params.abortSignal.removeEventListener('abort', onAbort);\r\n                },\r\n                complete: () => {\r\n                    if (resolve) {\r\n                        send({\r\n                            error: new RuntimeError(991 /* ɵRuntimeErrorCode.RESOURCE_COMPLETED_BEFORE_PRODUCING_VALUE */, ngDevMode && 'Resource completed before producing a value'),\r\n                        });\r\n                    }\r\n                    params.abortSignal.removeEventListener('abort', onAbort);\r\n                },\r\n            });\r\n            return promise;\r\n        },\r\n    });\r\n}\r\n\r\nexport { outputFromObservable, outputToObservable, pendingUntilEvent, rxResource, takeUntilDestroyed, toObservable, toSignal };\r\n\r\n"],
  "mappings": "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",
  "names": []
}
